<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BlockStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Slimefun</a> &gt; <a href="index.source.html" class="el_package">me.mrCookieSlime.Slimefun.api</a> &gt; <span class="el_source">BlockStorage.java</span></div><h1>BlockStorage.java</h1><pre class="source lang-java linenums">package me.mrCookieSlime.Slimefun.api;

import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.ParametersAreNonnullByDefault;

import org.apache.commons.lang.Validate;
import org.bukkit.Bukkit;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.configuration.file.YamlConfiguration;
import org.bukkit.entity.HumanEntity;
import org.bukkit.inventory.ItemStack;

import com.google.common.collect.ImmutableMap;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.stream.JsonWriter;

import io.github.bakedlibs.dough.common.CommonPatterns;
import io.github.thebusybiscuit.slimefun4.api.items.SlimefunItem;
import io.github.thebusybiscuit.slimefun4.implementation.Slimefun;
import io.github.thebusybiscuit.slimefun4.utils.NumberUtils;

import me.mrCookieSlime.CSCoreLibPlugin.Configuration.Config;
import me.mrCookieSlime.Slimefun.api.inventory.BlockMenu;
import me.mrCookieSlime.Slimefun.api.inventory.BlockMenuPreset;
import me.mrCookieSlime.Slimefun.api.inventory.UniversalBlockMenu;

// This class really needs a VERY big overhaul
public class BlockStorage {

    private static final String PATH_BLOCKS = &quot;data-storage/Slimefun/stored-blocks/&quot;;
    private static final String PATH_CHUNKS = &quot;data-storage/Slimefun/stored-chunks/&quot;;
    private static final String PATH_INVENTORIES = &quot;data-storage/Slimefun/stored-inventories/&quot;;

<span class="fc" id="L54">    private static final EmptyBlockData emptyBlockData = new EmptyBlockData();</span>

    private final World world;
<span class="nc" id="L57">    private final Map&lt;Location, Config&gt; storage = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L58">    private final Map&lt;Location, BlockMenu&gt; inventories = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L59">    private final Map&lt;String, Config&gt; blocksCache = new ConcurrentHashMap&lt;&gt;();</span>

<span class="fc" id="L61">    private static int chunkChanges = 0;</span>
<span class="fc" id="L62">    private static boolean universalInventoriesLoaded = false;</span>

<span class="nc" id="L64">    private int changes = 0;</span>
<span class="nc" id="L65">    private AtomicBoolean isMarkedForRemoval = new AtomicBoolean(false);</span>

    @Nullable
    public static BlockStorage getStorage(@Nonnull World world) {
<span class="fc" id="L69">        return Slimefun.getRegistry().getWorlds().get(world.getName());</span>
    }

    @Nonnull
    public static BlockStorage getOrCreate(@Nonnull World world) {
<span class="nc" id="L74">        BlockStorage storage = Slimefun.getRegistry().getWorlds().get(world.getName());</span>

<span class="nc bnc" id="L76" title="All 2 branches missed.">        if (storage == null) {</span>
<span class="nc" id="L77">            return new BlockStorage(world);</span>
        } else {
<span class="nc" id="L79">            return storage;</span>
        }
    }

    private static String serializeLocation(Location l) {
<span class="nc" id="L84">        return l.getWorld().getName() + ';' + l.getBlockX() + ';' + l.getBlockY() + ';' + l.getBlockZ();</span>
    }

    private static String serializeChunk(World world, int x, int z) {
<span class="nc" id="L88">        return world.getName() + &quot;;Chunk;&quot; + x + ';' + z;</span>
    }

    private static Location deserializeLocation(String l) {
        try {
<span class="nc" id="L93">            String[] components = CommonPatterns.SEMICOLON.split(l);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (components.length != 4) {</span>
<span class="nc" id="L95">                return null;</span>
            }

<span class="nc" id="L98">            World w = Bukkit.getWorld(components[0]);</span>

<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (w != null) {</span>
<span class="nc" id="L101">                return new Location(w, Integer.parseInt(components[1]), Integer.parseInt(components[2]), Integer.parseInt(components[3]));</span>
            }
<span class="nc" id="L103">        } catch (NumberFormatException x) {</span>
<span class="nc" id="L104">            Slimefun.logger().log(Level.WARNING, &quot;Could not parse Number&quot;, x);</span>
<span class="nc" id="L105">        }</span>
<span class="nc" id="L106">        return null;</span>
    }

<span class="nc" id="L109">    public BlockStorage(World w) {</span>
<span class="nc" id="L110">        this.world = w;</span>

<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (world.getName().indexOf('.') != -1) {</span>
<span class="nc" id="L113">            throw new IllegalArgumentException(&quot;Slimefun cannot deal with World names that contain a dot: &quot; + w.getName());</span>
        }

<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (Slimefun.getRegistry().getWorlds().containsKey(w.getName())) {</span>
            // Cancel the loading process if the world was already loaded
<span class="nc" id="L118">            return;</span>
        }

<span class="nc" id="L121">        Slimefun.logger().log(Level.INFO, &quot;Loading Blocks for World \&quot;{0}\&quot;&quot;, w.getName());</span>
<span class="nc" id="L122">        Slimefun.logger().log(Level.INFO, &quot;This may take a long time...&quot;);</span>

<span class="nc" id="L124">        File dir = new File(PATH_BLOCKS + w.getName());</span>

<span class="nc bnc" id="L126" title="All 2 branches missed.">        if (dir.exists()) {</span>
<span class="nc" id="L127">            loadBlocks(dir);</span>
        } else {
<span class="nc" id="L129">            dir.mkdirs();</span>
        }

<span class="nc" id="L132">        loadChunks();</span>
<span class="nc" id="L133">        loadInventories();</span>

<span class="nc" id="L135">        Slimefun.getRegistry().getWorlds().put(world.getName(), this);</span>
<span class="nc" id="L136">    }</span>

    private void loadBlocks(File directory) {
<span class="nc" id="L139">        long total = directory.listFiles().length;</span>
<span class="nc" id="L140">        long start = System.currentTimeMillis();</span>
<span class="nc" id="L141">        long done = 0;</span>
<span class="nc" id="L142">        long timestamp = System.currentTimeMillis();</span>
<span class="nc" id="L143">        long totalBlocks = 0;</span>
<span class="nc" id="L144">        int delay = Slimefun.getCfg().getInt(&quot;URID.info-delay&quot;);</span>

        try {
<span class="nc bnc" id="L147" title="All 2 branches missed.">            for (File file : directory.listFiles()) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (file.getName().equals(&quot;null.sfb&quot;)) {</span>
<span class="nc" id="L149">                    Slimefun.logger().log(Level.WARNING, &quot;File with corrupted blocks detected!&quot;);</span>
<span class="nc" id="L150">                    Slimefun.logger().log(Level.WARNING, &quot;Slimefun will simply skip this File, you should look inside though!&quot;);</span>
<span class="nc" id="L151">                    Slimefun.logger().log(Level.WARNING, file.getPath());</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">                } else if (file.getName().endsWith(&quot;.sfb&quot;)) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                    if (timestamp + delay &lt; System.currentTimeMillis()) {</span>
<span class="nc" id="L154">                        int progress = Math.round((((done * 100.0F) / total) * 100.0F) / 100.0F);</span>
<span class="nc" id="L155">                        Slimefun.logger().log(Level.INFO, &quot;Loading Blocks... {0}% done (\&quot;{1}\&quot;)&quot;, new Object[] { progress, world.getName() });</span>
<span class="nc" id="L156">                        timestamp = System.currentTimeMillis();</span>
                    }

<span class="nc" id="L159">                    FileConfiguration cfg = YamlConfiguration.loadConfiguration(file);</span>

<span class="nc bnc" id="L161" title="All 2 branches missed.">                    for (String key : cfg.getKeys(false)) {</span>
<span class="nc" id="L162">                        loadBlock(file, cfg, key);</span>
<span class="nc" id="L163">                        totalBlocks++;</span>
<span class="nc" id="L164">                    }</span>

<span class="nc" id="L166">                    done++;</span>
                }
            }
        } finally {
<span class="nc" id="L170">            long time = (System.currentTimeMillis() - start);</span>
<span class="nc" id="L171">            Slimefun.logger().log(Level.INFO, &quot;Loading Blocks... 100% (FINISHED - {0}ms)&quot;, time);</span>
<span class="nc" id="L172">            Slimefun.logger().log(Level.INFO, &quot;Loaded a total of {0} Blocks for World \&quot;{1}\&quot;&quot;, new Object[] { totalBlocks, world.getName() });</span>

<span class="nc bnc" id="L174" title="All 2 branches missed.">            if (totalBlocks &gt; 0) {</span>
<span class="nc" id="L175">                Slimefun.logger().log(Level.INFO, &quot;Avg: {0}ms/Block&quot;, NumberUtils.roundDecimalNumber((double) time / (double) totalBlocks));</span>
            }
        }
<span class="nc" id="L178">    }</span>

    private void loadBlock(File file, FileConfiguration cfg, String key) {
<span class="nc" id="L181">        Location l = deserializeLocation(key);</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (l == null) {</span>
            // That location was malformed, we will skip this one
<span class="nc" id="L185">            return;</span>
        }

        try {
<span class="nc" id="L189">            String json = cfg.getString(key);</span>
<span class="nc" id="L190">            Config blockInfo = parseBlockInfo(l, json);</span>

<span class="nc bnc" id="L192" title="All 4 branches missed.">            if (blockInfo != null &amp;&amp; blockInfo.contains(&quot;id&quot;)) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                if (storage.putIfAbsent(l, blockInfo) != null) {</span>
                    /*
                     * It should not be possible to have two blocks on the same location.
                     * Ignore the new entry if a block is already present and print an
                     * error to the console (if enabled).
                     */
<span class="nc bnc" id="L199" title="All 2 branches missed.">                    if (Slimefun.getRegistry().logDuplicateBlockEntries()) {</span>
<span class="nc" id="L200">                        Slimefun.logger().log(Level.INFO, &quot;Ignoring duplicate block @ {0}, {1}, {2} ({3} -&gt; {4})&quot;, new Object[] { l.getBlockX(), l.getBlockY(), l.getBlockZ(), blockInfo.getString(&quot;id&quot;), storage.get(l).getString(&quot;id&quot;) });</span>
                    }

<span class="nc" id="L203">                    return;</span>
                }

<span class="nc" id="L206">                String fileName = file.getName().replace(&quot;.sfb&quot;, &quot;&quot;);</span>

<span class="nc bnc" id="L208" title="All 2 branches missed.">                if (Slimefun.getRegistry().getTickerBlocks().contains(fileName)) {</span>
<span class="nc" id="L209">                    Slimefun.getTickerTask().enableTicker(l);</span>
                }
            }
<span class="nc" id="L212">        } catch (Exception x) {</span>
<span class="nc" id="L213">            Slimefun.logger().log(Level.WARNING, x, () -&gt; &quot;Failed to load &quot; + file.getName() + '(' + key + &quot;) for Slimefun &quot; + Slimefun.getVersion());</span>
<span class="nc" id="L214">        }</span>
<span class="nc" id="L215">    }</span>

    private void loadChunks() {
<span class="nc" id="L218">        File chunks = new File(PATH_CHUNKS + &quot;chunks.sfc&quot;);</span>

<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (chunks.exists()) {</span>
<span class="nc" id="L221">            FileConfiguration cfg = YamlConfiguration.loadConfiguration(chunks);</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">            for (String key : cfg.getKeys(false)) {</span>
                try {
<span class="nc bnc" id="L225" title="All 2 branches missed.">                    if (world.getName().equals(CommonPatterns.SEMICOLON.split(key)[0])) {</span>
<span class="nc" id="L226">                        BlockInfoConfig data = new BlockInfoConfig(parseJSON(cfg.getString(key)));</span>
<span class="nc" id="L227">                        Slimefun.getRegistry().getChunks().put(key, data);</span>
                    }
<span class="nc" id="L229">                } catch (Exception x) {</span>
<span class="nc" id="L230">                    Slimefun.logger().log(Level.WARNING, x, () -&gt; &quot;Failed to load &quot; + chunks.getName() + &quot; in World &quot; + world.getName() + '(' + key + &quot;) for Slimefun &quot; + Slimefun.getVersion());</span>
<span class="nc" id="L231">                }</span>
<span class="nc" id="L232">            }</span>
        }
<span class="nc" id="L234">    }</span>

    private void loadInventories() {
<span class="nc bnc" id="L237" title="All 2 branches missed.">        for (File file : new File(&quot;data-storage/Slimefun/stored-inventories&quot;).listFiles()) {</span>
<span class="nc bnc" id="L238" title="All 4 branches missed.">            if (file.getName().startsWith(world.getName()) &amp;&amp; file.getName().endsWith(&quot;.sfi&quot;)) {</span>
                try {
<span class="nc" id="L240">                    Location l = deserializeLocation(file.getName().replace(&quot;.sfi&quot;, &quot;&quot;));</span>

                    // We only want to only load this world's menus
<span class="nc bnc" id="L243" title="All 2 branches missed.">                    if (world != l.getWorld()) {</span>
<span class="nc" id="L244">                        continue;</span>
                    }

<span class="nc" id="L247">                    io.github.bakedlibs.dough.config.Config cfg = new io.github.bakedlibs.dough.config.Config(file);</span>
<span class="nc" id="L248">                    BlockMenuPreset preset = BlockMenuPreset.getPreset(cfg.getString(&quot;preset&quot;));</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">                    if (preset == null) {</span>
<span class="nc" id="L251">                        preset = BlockMenuPreset.getPreset(checkID(l));</span>
                    }

<span class="nc bnc" id="L254" title="All 2 branches missed.">                    if (preset != null) {</span>
<span class="nc" id="L255">                        inventories.put(l, new BlockMenu(preset, l, cfg));</span>
                    }
<span class="nc" id="L257">                } catch (Exception x) {</span>
<span class="nc" id="L258">                    Slimefun.logger().log(Level.SEVERE, x, () -&gt; &quot;An Error occurred while loading this Block Inventory: &quot; + file.getName());</span>
<span class="nc" id="L259">                }</span>
            }
        }

<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (universalInventoriesLoaded) {</span>
<span class="nc" id="L264">            return;</span>
        }

<span class="nc" id="L267">        universalInventoriesLoaded = true;</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">        for (File file : new File(&quot;data-storage/Slimefun/universal-inventories&quot;).listFiles()) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (file.getName().endsWith(&quot;.sfi&quot;)) {</span>
                try {
<span class="nc" id="L272">                    io.github.bakedlibs.dough.config.Config cfg = new io.github.bakedlibs.dough.config.Config(file);</span>
<span class="nc" id="L273">                    BlockMenuPreset preset = BlockMenuPreset.getPreset(cfg.getString(&quot;preset&quot;));</span>

<span class="nc bnc" id="L275" title="All 2 branches missed.">                    if (preset != null) {</span>
<span class="nc" id="L276">                        Slimefun.getRegistry().getUniversalInventories().put(preset.getID(), new UniversalBlockMenu(preset, cfg));</span>
                    }
<span class="nc" id="L278">                } catch (Exception x) {</span>
<span class="nc" id="L279">                    Slimefun.logger().log(Level.SEVERE, x, () -&gt; &quot;An Error occurred while loading this universal Inventory: &quot; + file.getName());</span>
<span class="nc" id="L280">                }</span>
            }
        }
<span class="nc" id="L283">    }</span>

    public void computeChanges() {
<span class="nc" id="L286">        changes = blocksCache.size();</span>

<span class="nc" id="L288">        Map&lt;Location, BlockMenu&gt; inventories2 = new HashMap&lt;&gt;(inventories);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for (Map.Entry&lt;Location, BlockMenu&gt; entry : inventories2.entrySet()) {</span>
<span class="nc" id="L290">            changes += entry.getValue().getUnsavedChanges();</span>
<span class="nc" id="L291">        }</span>

<span class="nc" id="L293">        Map&lt;String, UniversalBlockMenu&gt; universalInventories2 = new HashMap&lt;&gt;(Slimefun.getRegistry().getUniversalInventories());</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        for (Map.Entry&lt;String, UniversalBlockMenu&gt; entry : universalInventories2.entrySet()) {</span>
<span class="nc" id="L295">            changes += entry.getValue().getUnsavedChanges();</span>
<span class="nc" id="L296">        }</span>
<span class="nc" id="L297">    }</span>

    public int getChanges() {
<span class="nc" id="L300">        return changes;</span>
    }

    public void save() {
<span class="nc" id="L304">        computeChanges();</span>

<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (changes == 0) {</span>
<span class="nc" id="L307">            return;</span>
        }

<span class="nc" id="L310">        Slimefun.logger().log(Level.INFO, &quot;Saving block data for world \&quot;{0}\&quot; ({1} change(s) queued)&quot;, new Object[] { world.getName(), changes });</span>
<span class="nc" id="L311">        Map&lt;String, Config&gt; cache = new HashMap&lt;&gt;(blocksCache);</span>

<span class="nc bnc" id="L313" title="All 2 branches missed.">        for (Map.Entry&lt;String, Config&gt; entry : cache.entrySet()) {</span>
<span class="nc" id="L314">            blocksCache.remove(entry.getKey());</span>
<span class="nc" id="L315">            Config cfg = entry.getValue();</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (cfg.getKeys().isEmpty()) {</span>
<span class="nc" id="L318">                File file = cfg.getFile();</span>

<span class="nc bnc" id="L320" title="All 2 branches missed.">                if (file.exists()) {</span>
                    try {
<span class="nc" id="L322">                        Files.delete(file.toPath());</span>
<span class="nc" id="L323">                    } catch (IOException e) {</span>
<span class="nc" id="L324">                        Slimefun.logger().log(Level.WARNING, e, () -&gt; &quot;Could not delete file \&quot;&quot; + file.getName() + '&quot;');</span>
<span class="nc" id="L325">                    }</span>
                }
<span class="nc" id="L327">            } else {</span>
<span class="nc" id="L328">                File tmpFile = new File(cfg.getFile().getParentFile(), cfg.getFile().getName() + &quot;.tmp&quot;);</span>
<span class="nc" id="L329">                cfg.save(tmpFile);</span>

                try {
<span class="nc" id="L332">                    Files.move(tmpFile.toPath(), cfg.getFile().toPath(), StandardCopyOption.ATOMIC_MOVE);</span>
<span class="nc" id="L333">                } catch (IOException x) {</span>
<span class="nc" id="L334">                    Slimefun.logger().log(Level.SEVERE, x, () -&gt; &quot;An Error occurred while copying a temporary File for Slimefun &quot; + Slimefun.getVersion());</span>
<span class="nc" id="L335">                }</span>
            }
<span class="nc" id="L337">        }</span>

<span class="nc" id="L339">        Map&lt;Location, BlockMenu&gt; unsavedInventories = new HashMap&lt;&gt;(inventories);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        for (Map.Entry&lt;Location, BlockMenu&gt; entry : unsavedInventories.entrySet()) {</span>
<span class="nc" id="L341">            entry.getValue().save(entry.getKey());</span>
<span class="nc" id="L342">        }</span>

<span class="nc" id="L344">        Map&lt;String, UniversalBlockMenu&gt; unsavedUniversalInventories = new HashMap&lt;&gt;(Slimefun.getRegistry().getUniversalInventories());</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        for (Map.Entry&lt;String, UniversalBlockMenu&gt; entry : unsavedUniversalInventories.entrySet()) {</span>
<span class="nc" id="L346">            entry.getValue().save();</span>
<span class="nc" id="L347">        }</span>

<span class="nc" id="L349">        changes = 0;</span>
<span class="nc" id="L350">    }</span>

    public void saveAndRemove() {
<span class="nc" id="L353">        save();</span>
<span class="nc" id="L354">        saveChunks();</span>
<span class="nc" id="L355">        isMarkedForRemoval.set(true);</span>
<span class="nc" id="L356">    }</span>

    public boolean isMarkedForRemoval() {
<span class="nc" id="L359">        return isMarkedForRemoval.get();</span>
    }

    public static void saveChunks() {
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if (chunkChanges &gt; 0) {</span>
<span class="nc" id="L364">            File chunks = new File(PATH_CHUNKS + &quot;chunks.sfc&quot;);</span>
<span class="nc" id="L365">            Config cfg = new Config(PATH_CHUNKS + &quot;chunks.temp&quot;);</span>

<span class="nc bnc" id="L367" title="All 2 branches missed.">            for (Map.Entry&lt;String, BlockInfoConfig&gt; entry : Slimefun.getRegistry().getChunks().entrySet()) {</span>
                // Saving empty chunk data is pointless
<span class="nc bnc" id="L369" title="All 2 branches missed.">                if (!entry.getValue().getKeys().isEmpty()) {</span>
<span class="nc" id="L370">                    cfg.setValue(entry.getKey(), entry.getValue().toJSON());</span>
                }
<span class="nc" id="L372">            }</span>

<span class="nc" id="L374">            cfg.save(chunks);</span>

<span class="nc" id="L376">            chunkChanges = 0;</span>
        }
<span class="nc" id="L378">    }</span>

    /**
     * This will return an {@link ImmutableMap} of the underline {@code Map&lt;String, Config&gt;} of
     * this worlds {@link BlockStorage}.
     *
     * @return An {@link ImmutableMap} of the raw data.
     */
    @Nonnull
    public Map&lt;Location, Config&gt; getRawStorage() {
<span class="nc" id="L388">        return ImmutableMap.copyOf(this.storage);</span>
    }

    /**
     * This will return an {@link ImmutableMap} of the underline {@code Map&lt;String, Config&gt;} of
     * this worlds {@link BlockStorage}. If there is no registered world then this will return null.
     *
     * @param world
     *            The world of which to fetch the data from.
     * @return An {@link ImmutableMap} of the raw data or null if the world isn't registered.
     */
    @Nullable
    public static Map&lt;Location, Config&gt; getRawStorage(@Nonnull World world) {
<span class="nc" id="L401">        Validate.notNull(world, &quot;World cannot be null!&quot;);</span>

<span class="nc" id="L403">        BlockStorage storage = getStorage(world);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (storage != null) {</span>
<span class="nc" id="L405">            return storage.getRawStorage();</span>
        } else {
<span class="nc" id="L407">            return null;</span>
        }
    }

    public static void store(Block block, ItemStack item) {
<span class="nc" id="L412">        SlimefunItem sfitem = SlimefunItem.getByItem(item);</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (sfitem != null) {</span>
<span class="nc" id="L415">            addBlockInfo(block, &quot;id&quot;, sfitem.getId(), true);</span>
        }
<span class="nc" id="L417">    }</span>

    public static void store(Block block, String item) {
<span class="nc" id="L420">        addBlockInfo(block, &quot;id&quot;, item, true);</span>
<span class="nc" id="L421">    }</span>

    /**
     * Retrieves the SlimefunItem's ItemStack from the specified Block.
     * If the specified Block is registered in BlockStorage,
     * its data will be erased from it, regardless of the returned value.
     *
     * @param block
     *            the block to retrieve the ItemStack from
     * 
     * @return the SlimefunItem's ItemStack corresponding to the block if it has one, otherwise null
     */
    @Nullable
    public static ItemStack retrieve(@Nonnull Block block) {
<span class="nc" id="L435">        SlimefunItem item = check(block);</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">        if (item == null) {</span>
<span class="nc" id="L438">            return null;</span>
        } else {
<span class="nc" id="L440">            clearBlockInfo(block);</span>
<span class="nc" id="L441">            return item.getItem();</span>
        }
    }

    @Nonnull
    public static Config getLocationInfo(Location l) {
<span class="nc" id="L447">        BlockStorage storage = getStorage(l.getWorld());</span>

<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (storage == null) {</span>
<span class="nc" id="L450">            return emptyBlockData;</span>
        }

<span class="nc" id="L453">        Config cfg = storage.storage.get(l);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">        return cfg == null ? emptyBlockData : cfg;</span>
    }

    @Nonnull
    private static Map&lt;String, String&gt; parseJSON(String json) {
<span class="nc" id="L459">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L461" title="All 4 branches missed.">        if (json != null &amp;&amp; json.length() &gt; 2) {</span>
<span class="nc" id="L462">            JsonParser parser = new JsonParser();</span>
<span class="nc" id="L463">            JsonObject obj = parser.parse(json).getAsJsonObject();</span>

<span class="nc bnc" id="L465" title="All 2 branches missed.">            for (Map.Entry&lt;String, JsonElement&gt; entry : obj.entrySet()) {</span>
<span class="nc" id="L466">                map.put(entry.getKey(), entry.getValue().getAsString());</span>
<span class="nc" id="L467">            }</span>
        }

<span class="nc" id="L470">        return map;</span>
    }

    private static BlockInfoConfig parseBlockInfo(Location l, String json) {
        try {
<span class="nc" id="L475">            return new BlockInfoConfig(parseJSON(json));</span>
<span class="nc" id="L476">        } catch (Exception x) {</span>
<span class="nc" id="L477">            Logger logger = Slimefun.logger();</span>
<span class="nc" id="L478">            logger.log(Level.WARNING, x.getClass().getName());</span>
<span class="nc" id="L479">            logger.log(Level.WARNING, &quot;Failed to parse BlockInfo for Block @ {0}, {1}, {2}&quot;, new Object[] { l.getBlockX(), l.getBlockY(), l.getBlockZ() });</span>
<span class="nc" id="L480">            logger.log(Level.WARNING, json);</span>
<span class="nc" id="L481">            logger.log(Level.WARNING, &quot;&quot;);</span>
<span class="nc" id="L482">            logger.log(Level.WARNING, &quot;IGNORE THIS ERROR UNLESS IT IS SPAMMING&quot;);</span>
<span class="nc" id="L483">            logger.log(Level.WARNING, &quot;&quot;);</span>
<span class="nc" id="L484">            logger.log(Level.SEVERE, x, () -&gt; &quot;An Error occurred while parsing Block Info for Slimefun &quot; + Slimefun.getVersion());</span>
<span class="nc" id="L485">            return null;</span>
        }
    }

    private static String serializeBlockInfo(Config cfg) {
<span class="nc" id="L490">        StringWriter string = new StringWriter();</span>

<span class="nc" id="L492">        try (JsonWriter writer = new JsonWriter(string)) {</span>
<span class="nc" id="L493">            writer.setLenient(true);</span>
<span class="nc" id="L494">            writer.beginObject();</span>

<span class="nc bnc" id="L496" title="All 2 branches missed.">            for (String key : cfg.getKeys()) {</span>
<span class="nc" id="L497">                writer.name(key).value(cfg.getString(key));</span>
<span class="nc" id="L498">            }</span>

<span class="nc" id="L500">            writer.endObject();</span>
<span class="nc" id="L501">            return string.toString();</span>
<span class="nc" id="L502">        } catch (IOException x) {</span>
<span class="nc" id="L503">            Slimefun.logger().log(Level.SEVERE, &quot;An error occurred while serializing BlockInfo&quot;, x);</span>
<span class="nc" id="L504">            return null;</span>
        }
    }

    public static String getLocationInfo(Location l, String key) {
<span class="nc" id="L509">        return getLocationInfo(l).getString(key);</span>
    }

    public static void addBlockInfo(Location l, String key, String value) {
<span class="nc" id="L513">        addBlockInfo(l, key, value, false);</span>
<span class="nc" id="L514">    }</span>

    public static void addBlockInfo(Block block, String key, String value) {
<span class="nc" id="L517">        addBlockInfo(block.getLocation(), key, value);</span>
<span class="nc" id="L518">    }</span>

    public static void addBlockInfo(Block block, String key, String value, boolean updateTicker) {
<span class="nc" id="L521">        addBlockInfo(block.getLocation(), key, value, updateTicker);</span>
<span class="nc" id="L522">    }</span>

    public static void addBlockInfo(Location l, String key, String value, boolean updateTicker) {
<span class="nc" id="L525">        Config cfg = getLocationInfo(l);</span>

<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (cfg == emptyBlockData) {</span>
<span class="nc" id="L528">            cfg = new BlockInfoConfig();</span>
        }

<span class="nc" id="L531">        cfg.setValue(key, value);</span>
<span class="nc" id="L532">        setBlockInfo(l, cfg, updateTicker);</span>
<span class="nc" id="L533">    }</span>

    public static boolean hasBlockInfo(Block block) {
<span class="nc" id="L536">        return hasBlockInfo(block.getLocation());</span>
    }

    public static boolean hasBlockInfo(Location l) {
<span class="fc" id="L540">        BlockStorage storage = getStorage(l.getWorld());</span>

<span class="pc bpc" id="L542" title="1 of 2 branches missed.">        if (storage != null) {</span>
<span class="nc" id="L543">            Config cfg = storage.storage.get(l);</span>
<span class="nc bnc" id="L544" title="All 4 branches missed.">            return cfg != null &amp;&amp; cfg.getString(&quot;id&quot;) != null;</span>
        } else {
<span class="fc" id="L546">            return false;</span>
        }
    }

    private static void setBlockInfo(Location l, Config cfg, boolean updateTicker) {
<span class="nc" id="L551">        BlockStorage storage = getStorage(l.getWorld());</span>

<span class="nc bnc" id="L553" title="All 2 branches missed.">        if (storage == null) {</span>
<span class="nc" id="L554">            Slimefun.logger().warning(&quot;Could not set Block info for non-registered World '&quot; + l.getWorld().getName() + &quot;'. Is some plugin trying to store data in a fake world?&quot;);</span>
<span class="nc" id="L555">            return;</span>
        }

<span class="nc" id="L558">        storage.storage.put(l, cfg);</span>
<span class="nc" id="L559">        String id = cfg.getString(&quot;id&quot;);</span>
<span class="nc" id="L560">        BlockMenuPreset preset = BlockMenuPreset.getPreset(id);</span>

<span class="nc bnc" id="L562" title="All 2 branches missed.">        if (preset != null) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (BlockMenuPreset.isUniversalInventory(id)) {</span>
<span class="nc" id="L564">                Slimefun.getRegistry().getUniversalInventories().computeIfAbsent(id, key -&gt; new UniversalBlockMenu(preset));</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">            } else if (!storage.hasInventory(l)) {</span>
<span class="nc" id="L566">                File file = new File(PATH_INVENTORIES + serializeLocation(l) + &quot;.sfi&quot;);</span>

<span class="nc bnc" id="L568" title="All 2 branches missed.">                if (file.exists()) {</span>
<span class="nc" id="L569">                    BlockMenu inventory = new BlockMenu(preset, l, new io.github.bakedlibs.dough.config.Config(file));</span>
<span class="nc" id="L570">                    storage.inventories.put(l, inventory);</span>
<span class="nc" id="L571">                } else {</span>
<span class="nc" id="L572">                    storage.loadInventory(l, preset);</span>
                }
            }
        }

<span class="nc" id="L577">        refreshCache(storage, l, id, serializeBlockInfo(cfg), updateTicker);</span>
<span class="nc" id="L578">    }</span>

    public static void setBlockInfo(Block b, String json, boolean updateTicker) {
<span class="nc" id="L581">        setBlockInfo(b.getLocation(), json, updateTicker);</span>
<span class="nc" id="L582">    }</span>

    public static void setBlockInfo(Location l, String json, boolean updateTicker) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        Config blockInfo = json == null ? new BlockInfoConfig() : parseBlockInfo(l, json);</span>

<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (blockInfo == null) {</span>
<span class="nc" id="L588">            return;</span>
        }

<span class="nc" id="L591">        setBlockInfo(l, blockInfo, updateTicker);</span>
<span class="nc" id="L592">    }</span>

    public static void clearBlockInfo(Block block) {
<span class="nc" id="L595">        clearBlockInfo(block.getLocation());</span>
<span class="nc" id="L596">    }</span>

    public static void clearBlockInfo(Location l) {
<span class="nc" id="L599">        clearBlockInfo(l, true);</span>
<span class="nc" id="L600">    }</span>

    public static void clearBlockInfo(Block b, boolean destroy) {
<span class="nc" id="L603">        clearBlockInfo(b.getLocation(), destroy);</span>
<span class="nc" id="L604">    }</span>

    public static void clearBlockInfo(Location l, boolean destroy) {
<span class="nc" id="L607">        Slimefun.getTickerTask().queueDelete(l, destroy);</span>
<span class="nc" id="L608">    }</span>

    /**
     * &lt;strong&gt;Do not call this method!&lt;/strong&gt;.
     * This method is used for internal purposes only.
     * 
     * @param l
     *            The {@link Location}
     * @param destroy
     *            Whether to completely destroy the block data
     */
    public static void deleteLocationInfoUnsafely(Location l, boolean destroy) {
<span class="nc" id="L620">        BlockStorage storage = getStorage(l.getWorld());</span>

<span class="nc bnc" id="L622" title="All 2 branches missed.">        if (storage == null) {</span>
<span class="nc" id="L623">            throw new IllegalStateException(&quot;World \&quot;&quot; + l.getWorld().getName() + &quot;\&quot; seems to have been deleted. Do not call unsafe methods directly!&quot;);</span>
        }

<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (hasBlockInfo(l)) {</span>
<span class="nc" id="L627">            refreshCache(storage, l, getLocationInfo(l).getString(&quot;id&quot;), null, destroy);</span>
<span class="nc" id="L628">            storage.storage.remove(l);</span>
        }

<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (destroy) {</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">            if (storage.hasInventory(l)) {</span>
<span class="nc" id="L633">                storage.clearInventory(l);</span>
            }

<span class="nc" id="L636">            UniversalBlockMenu universalInventory = getUniversalInventory(l);</span>

<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (universalInventory != null) {</span>
<span class="nc" id="L639">                universalInventory.close();</span>
<span class="nc" id="L640">                universalInventory.save();</span>
            }

<span class="nc" id="L643">            Slimefun.getTickerTask().disableTicker(l);</span>
        }
<span class="nc" id="L645">    }</span>

    @ParametersAreNonnullByDefault
    public static void moveBlockInfo(Location from, Location to) {
<span class="nc" id="L649">        Slimefun.getTickerTask().queueMove(from, to);</span>
<span class="nc" id="L650">    }</span>

    /**
     * &lt;strong&gt;Do not call this method!&lt;/strong&gt;.
     * This method is used for internal purposes only.
     * 
     * @param from
     *            The origin {@link Location}
     * @param to
     *            The destination {@link Location}
     */
    @ParametersAreNonnullByDefault
    public static void moveLocationInfoUnsafely(Location from, Location to) {
<span class="nc bnc" id="L663" title="All 2 branches missed.">        if (!hasBlockInfo(from)) {</span>
<span class="nc" id="L664">            return;</span>
        }

<span class="nc" id="L667">        BlockStorage storage = getStorage(from.getWorld());</span>
<span class="nc" id="L668">        Config previousData = getLocationInfo(from);</span>
<span class="nc" id="L669">        setBlockInfo(to, previousData, true);</span>

<span class="nc bnc" id="L671" title="All 2 branches missed.">        if (storage.inventories.containsKey(from)) {</span>
<span class="nc" id="L672">            BlockMenu menu = storage.inventories.get(from);</span>
<span class="nc" id="L673">            storage.inventories.put(to, menu);</span>
<span class="nc" id="L674">            storage.clearInventory(from);</span>
<span class="nc" id="L675">            menu.move(to);</span>
        }

<span class="nc" id="L678">        refreshCache(storage, from, previousData.getString(&quot;id&quot;), null, true);</span>
<span class="nc" id="L679">        storage.storage.remove(from);</span>

<span class="nc" id="L681">        Slimefun.getTickerTask().disableTicker(from);</span>
<span class="nc" id="L682">    }</span>

    private static void refreshCache(BlockStorage storage, Location l, String key, String value, boolean updateTicker) {
<span class="nc bnc" id="L685" title="All 2 branches missed.">        if (key == null) {</span>
            /**
             * This Block is no longer valid...
             * Fixes #1577
             */
<span class="nc" id="L690">            return;</span>
        }

<span class="nc" id="L693">        Config cfg = storage.blocksCache.computeIfAbsent(key, k -&gt; new Config(PATH_BLOCKS + l.getWorld().getName() + '/' + key + &quot;.sfb&quot;));</span>
<span class="nc" id="L694">        cfg.setValue(serializeLocation(l), value);</span>

<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (updateTicker) {</span>
<span class="nc" id="L697">            SlimefunItem item = SlimefunItem.getById(key);</span>

<span class="nc bnc" id="L699" title="All 6 branches missed.">            if (item != null &amp;&amp; item.isTicking() &amp;&amp; value != null) {</span>
<span class="nc" id="L700">                Slimefun.getTickerTask().enableTicker(l);</span>
            }
        }
<span class="nc" id="L703">    }</span>

    @Nullable
    public static SlimefunItem check(@Nonnull Block b) {
<span class="nc" id="L707">        String id = checkID(b);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">        return id == null ? null : SlimefunItem.getById(id);</span>
    }

    @Nullable
    public static SlimefunItem check(@Nonnull Location l) {
<span class="nc" id="L713">        String id = checkID(l);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        return id == null ? null : SlimefunItem.getById(id);</span>
    }

    public static boolean check(Block block, String slimefunItem) {
<span class="nc" id="L718">        String id = checkID(block);</span>
<span class="nc bnc" id="L719" title="All 4 branches missed.">        return id != null &amp;&amp; id.equals(slimefunItem);</span>
    }

    @Nullable
    public static String checkID(@Nonnull Block b) {
        // Only access the BlockState when on the main thread
<span class="nc bnc" id="L725" title="All 4 branches missed.">        if (Bukkit.isPrimaryThread() &amp;&amp; Slimefun.getBlockDataService().isTileEntity(b.getType())) {</span>
<span class="nc" id="L726">            Optional&lt;String&gt; blockData = Slimefun.getBlockDataService().getBlockData(b);</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">            if (blockData.isPresent()) {</span>
<span class="nc" id="L729">                return blockData.get();</span>
            }
        }

<span class="nc" id="L733">        return checkID(b.getLocation());</span>
    }

    @Nullable
    public static String checkID(@Nonnull Location l) {
<span class="nc" id="L738">        return getLocationInfo(l, &quot;id&quot;);</span>
    }

    public static boolean check(@Nonnull Location l, @Nullable String slimefunItem) {
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (slimefunItem == null) {</span>
<span class="nc" id="L743">            return false;</span>
        }

<span class="nc" id="L746">        String id = checkID(l);</span>
<span class="nc bnc" id="L747" title="All 4 branches missed.">        return id != null &amp;&amp; id.equals(slimefunItem);</span>
    }

    public static boolean isWorldLoaded(@Nonnull World world) {
<span class="nc" id="L751">        return Slimefun.getRegistry().getWorlds().containsKey(world.getName());</span>
    }

    public BlockMenu loadInventory(Location l, BlockMenuPreset preset) {
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (preset == null) {</span>
<span class="nc" id="L756">            return null;</span>
        }

<span class="nc" id="L759">        BlockMenu menu = new BlockMenu(preset, l);</span>
<span class="nc" id="L760">        inventories.put(l, menu);</span>
<span class="nc" id="L761">        return menu;</span>
    }

    /**
     * Reload a BlockMenu based on the preset. This method is solely for if you wish to reload
     * based on data from the preset.
     *
     * @param l
     *            The location of the Block.
     */
    public void reloadInventory(Location l) {
<span class="nc" id="L772">        BlockMenu menu = this.inventories.get(l);</span>

<span class="nc bnc" id="L774" title="All 2 branches missed.">        if (menu != null) {</span>
<span class="nc" id="L775">            menu.reload();</span>
        }
<span class="nc" id="L777">    }</span>

    public void clearInventory(Location l) {
<span class="nc" id="L780">        BlockMenu menu = getInventory(l);</span>

<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (menu != null) {</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">            for (HumanEntity human : new ArrayList&lt;&gt;(menu.toInventory().getViewers())) {</span>
                // Prevents &quot;java.lang.IllegalStateException: Asynchronous entity add!&quot;
                // when closing the inventory while holding an item
<span class="nc" id="L786">                Slimefun.runSync(human::closeInventory);</span>
<span class="nc" id="L787">            }</span>

<span class="nc" id="L789">            inventories.get(l).delete(l);</span>
<span class="nc" id="L790">            inventories.remove(l);</span>
        }
<span class="nc" id="L792">    }</span>

    public boolean hasInventory(Location l) {
<span class="nc" id="L795">        return inventories.containsKey(l);</span>
    }

    public static boolean hasUniversalInventory(String id) {
<span class="nc" id="L799">        return Slimefun.getRegistry().getUniversalInventories().containsKey(id);</span>
    }

    public static UniversalBlockMenu getUniversalInventory(Block block) {
<span class="nc" id="L803">        return getUniversalInventory(block.getLocation());</span>
    }

    public static UniversalBlockMenu getUniversalInventory(Location l) {
<span class="nc" id="L807">        String id = checkID(l);</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">        return id == null ? null : getUniversalInventory(id);</span>
    }

    public static UniversalBlockMenu getUniversalInventory(String id) {
<span class="nc" id="L812">        return Slimefun.getRegistry().getUniversalInventories().get(id);</span>
    }

    public static BlockMenu getInventory(Block b) {
<span class="nc" id="L816">        return getInventory(b.getLocation());</span>
    }

    public static boolean hasInventory(Block b) {
<span class="nc" id="L820">        BlockStorage storage = getStorage(b.getWorld());</span>

<span class="nc bnc" id="L822" title="All 2 branches missed.">        if (storage == null) {</span>
<span class="nc" id="L823">            return false;</span>
        } else {
<span class="nc" id="L825">            return storage.hasInventory(b.getLocation());</span>
        }
    }

    public static BlockMenu getInventory(Location l) {
<span class="nc" id="L830">        BlockStorage storage = getStorage(l.getWorld());</span>

<span class="nc bnc" id="L832" title="All 2 branches missed.">        if (storage == null) {</span>
<span class="nc" id="L833">            return null;</span>
        }

<span class="nc" id="L836">        BlockMenu menu = storage.inventories.get(l);</span>

<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (menu != null) {</span>
<span class="nc" id="L839">            return menu;</span>
        } else {
<span class="nc" id="L841">            return storage.loadInventory(l, BlockMenuPreset.getPreset(checkID(l)));</span>
        }
    }

    public static Config getChunkInfo(World world, int x, int z) {
        try {
<span class="nc bnc" id="L847" title="All 2 branches missed.">            if (!isWorldLoaded(world)) {</span>
<span class="nc" id="L848">                return emptyBlockData;</span>
            }

<span class="nc" id="L851">            String key = serializeChunk(world, x, z);</span>
<span class="nc" id="L852">            BlockInfoConfig cfg = Slimefun.getRegistry().getChunks().get(key);</span>

<span class="nc bnc" id="L854" title="All 2 branches missed.">            if (cfg == null) {</span>
<span class="nc" id="L855">                cfg = new BlockInfoConfig();</span>
<span class="nc" id="L856">                Slimefun.getRegistry().getChunks().put(key, cfg);</span>
            }

<span class="nc" id="L859">            return cfg;</span>
<span class="nc" id="L860">        } catch (Exception e) {</span>
<span class="nc" id="L861">            Slimefun.logger().log(Level.SEVERE, e, () -&gt; &quot;Failed to parse ChunkInfo for Slimefun &quot; + Slimefun.getVersion());</span>
<span class="nc" id="L862">            return emptyBlockData;</span>
        }
    }

    public static void setChunkInfo(World world, int x, int z, String key, String value) {
<span class="nc" id="L867">        String serializedChunk = serializeChunk(world, x, z);</span>
<span class="nc" id="L868">        BlockInfoConfig cfg = Slimefun.getRegistry().getChunks().get(serializedChunk);</span>

<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (cfg == null) {</span>
<span class="nc" id="L871">            cfg = new BlockInfoConfig();</span>
<span class="nc" id="L872">            Slimefun.getRegistry().getChunks().put(serializedChunk, cfg);</span>
        }

<span class="nc" id="L875">        cfg.setValue(key, value);</span>

<span class="nc" id="L877">        chunkChanges++;</span>
<span class="nc" id="L878">    }</span>

    public static boolean hasChunkInfo(World world, int x, int z) {
<span class="nc" id="L881">        String serializedChunk = serializeChunk(world, x, z);</span>
<span class="nc" id="L882">        return Slimefun.getRegistry().getChunks().containsKey(serializedChunk);</span>
    }

    public static String getChunkInfo(World world, int x, int z, String key) {
<span class="nc" id="L886">        return getChunkInfo(world, x, z).getString(key);</span>
    }

    public static String getBlockInfoAsJson(Block block) {
<span class="nc" id="L890">        return getBlockInfoAsJson(block.getLocation());</span>
    }

    public static String getBlockInfoAsJson(Location l) {
<span class="nc" id="L894">        return serializeBlockInfo(getLocationInfo(l));</span>
    }

    public boolean hasUniversalInventory(Block block) {
<span class="nc" id="L898">        return hasUniversalInventory(block.getLocation());</span>
    }

    public boolean hasUniversalInventory(Location l) {
<span class="nc" id="L902">        String id = checkID(l);</span>
<span class="nc bnc" id="L903" title="All 4 branches missed.">        return id != null &amp;&amp; hasUniversalInventory(id);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>